syntax = "proto3";
import "google/protobuf/timestamp.proto";

message Felt252 {
    bytes elements = 1;
}

message Hash {
    bytes elements = 1;
}

message Address {
    bytes elements = 1;
}

message PeerID {
    bytes id = 1;
}

message ChainID {
    bytes id = 1;
}

message BlockID {
    Hash hash = 1;
    // TODO: do we need commitment on block parts, if it is big?
}

message Signature {
    repeated Felt252 parts = 1;
}

message BlockHeader {
    BlockID parent_block = 1;
    uint64 height = 2;
    google.protobuf.Timestamp time = 3;

    Hash state = 4;
    Address sequencer_address = 5;

    Hash strand_blook_proof = 6; // for Kth block behind
    Hash transactions = 7; // merkle, good also for sync, to not split/merge/reorder
    // Hash state_diffs = 8;  TBD: chain, avoid the need to build Merkle when syncing. Problem: order not clear (issuance? may have several for the same contract strawn apart)
    Hash events = 9; // merkle, avoid the need to execute when syncing. By order of issuance

    uint32 protocol_version = 10;
    ChainID chain_id = 11;
}

message BlockProof {
    bytes proof = 1;
}

message InvokeTransaction
{
    Address sender_address = 1;
    repeated Felt252 calldata = 2;
    Signature signature = 3;
    Felt252 max_fee = 4;
    Felt252 nonce = 5;
    Felt252 version = 6;
}


message DeclareTransaction
{
    Address sender_address = 1;
    Hash class_hash = 2;
    Hash compiled_hash = 3;
    Signature signature = 4;
    Felt252 max_fee = 5;
    Felt252 nonce = 6;
    Felt252 version = 7;

}

message L1HandlerTransaction {
    Address contract = 1;
    Felt252 entry_point_selector = 2;
    repeated Felt252 calldata = 3;
    Felt252 nonce = 5;
    Felt252 version = 6;
}

// NOTE: not keeping old tx types

message Transaction
{
    oneof txn
    {
        InvokeTransaction invoke = 1;
        DeclareTransaction declare = 2;
        L1HandlerTransaction l1handler = 3;
    }
}

message Event {
    Felt252 from_address = 1;
    repeated Felt252 keys = 2;
    repeated Felt252 data = 3;
}

// leafs of the contract state tre
message ContractState {
    Hash address = 1; // the key
    Hash class = 2;
    Hash storage = 3; // patricia
    uint64 nonce = 4;
}

// is it better to separate the definition from the hashes? (will need to repeate the hashes
// for the definitions stream)
// or, make the definitions optional? maybe it is enough to know only that a class exists, not its definition
// which may be fetched lazily later.
message Class {
    Hash definition_hash = 1;
    Hash compiled_hash = 2;
    bytes definition = 3; // compressed?
}

// optimized for flat storage, not through a trie (not sharing key prefixes)
message ContractStoredValue {
    Felt252 key = 1;
    Felt252 value = 2;
}
