syntax = "proto3";

import "p2p/proto/common.proto";
import "p2p/proto/transaction.proto";

// Support also non-validating node that wants to know of the mempool (e.g. to estimate fee in case of first price)
// Result is PooledTransactions+
message PooledTransactionsRequest
{
    message Known {
        oneof known {
            Hashes txs    = 1;  // for mempool of 2000 txs, this will be 64K. Can use Hash32 instead (8K)...
            uint64 marker = 2;  // since last returned marker.
        }
    }
    optional Known known = 1;
}

// Can be also a push, similar to NewBlock. So a full node that accepts a new transaction from a wallet
// can propagate it without being pulled
message PolledTransactionsResponse {
    uint64   marker                   = 1;  // optional, if the peer supports that.

    oneof responses {
        Transactions new      = 2;
        Hashes       included = 3; // those txs no longer in the pool since they were included.
                                    // just send the hash. (note: a node should remove txs with same/lower nonce)
                                    // TBD: Merkle proofs of contract state instead?
                                    // TBD: trusted. Alternative is to sync on transactions or on contract diff (remove key-value) to get latest nonce
                                    // lighter data than tracking new blocks to read txs.
        Fin          fin      = 4;
    }
}
